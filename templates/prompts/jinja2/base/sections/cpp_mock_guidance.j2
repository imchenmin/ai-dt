{# MockCpp Code Generation Template - Optimized for LLM #}
{% if dependencies.called_functions and dependencies.called_functions|length > 0 %}
2. **MOCK_REQUIREMENTS**: Generate mocks for these external dependencies:
{% for func in dependencies.called_functions %}
   - Function: `{{ func.name }}` | Signature: `{{ func.signature }}`
{% endfor %}

3. **MOCKCPP_SYNTAX_RULES**:
   **LANGUAGE**: {% if target_function.language.display_name is defined %}{{ target_function.language.display_name }}{% elif target_function.language == 1 or target_function.language == 'c' %}C{% elif target_function.language == 2 or target_function.language == 'c++' %}C++{% else %}{{ target_function.language }}{% endif %}
   **MANDATORY_CHAIN_ORDER**: MOCKER(func) -> [.stubs()|.expects()] -> [.with()] -> .will()
   
   **BASIC_PATTERNS**:
   ```cpp
   // Pattern 1: Simple stub
   MOCKER(function_name).stubs().with(any()).will(returnValue(value));
   
   // Pattern 2: Expectation with count
   MOCKER(function_name).expects(once()).with(constraints).will(action);
   ```
   **OUTPUT_PARAMETER_RULES**:
   ```cpp
   // RULE: Use outBoundP(ptr, size) for non-const pointer outputs
   int data = 42;
   MOCKER(func).stubs().with(any(), outBoundP((int*)&data, sizeof(int))).will(returnValue(0));
   
   // RULE: Never use outBoundP with const parameters
   MOCKER(func).stubs().with(eq((const char*)"value")).will(returnValue(0));
   ```
   **METHOD_REFERENCE**:
   - SETUP: .stubs() | .defaults() | .expects(never()|once()|exactly(n)|atLeast(n)|atMost(n))
   - CONSTRAINTS: .with(any()|eq(v)|neq(v)|gt(v)|lt(v)|spy(var)|checkWith(func)|outBound(var)|outBoundP(ptr,size)|mirror(ptr,size))
   - ACTIONS: .will(returnValue(v)|repeat(v,times)|returnObjectList(r1,r2)|invoke(func)|increase(from,to)|throws(e)|die(code))
   **TEST_STRUCTURE_TEMPLATE**:
   ```cpp
   TEST_F(TestClass, TestMethod) {
       // Setup mocks
       MOCKER(func).stubs().will(returnValue(value));
       // Execute
       result = target_function();
       // Verify
       EXPECT_EQ(expected, result);
       // Mock verification (automatic in teardown)
   }
   ```
   **CONSTRAINTS**:
   - NEVER mock: malloc, free, printf, strcpy, system functions
   - ONLY mock: project-defined functions
   - NEVER redefine: TEST, TEST_F, EXPECT_* macros (provided by gtest.h)
   - ALWAYS match: pointer types exactly in outBoundP
   
   **REQUIRED_INCLUDES**:
   ```cpp
   #include <gtest/gtest.h>
   #include <mockcpp/mockcpp.hpp>
   extern "C" { #include "target_header.h" }
   ```
   
   **GENERATION_RULES**:
   - Use MOCKER(function_name) for C functions and static methods
   - Use MockObject<Class> obj; MOCK_METHOD(obj,method) for class methods
   - Always specify .will() for functions with return values
   - Use outBound(var) for reference parameters, outBoundP(ptr,size) for pointer arrays
   - Use spy(var) to capture input values for verification
   - Ensure exact type matching between mock and function signature
   - Call GlobalMockObject::verify() in teardown for verification
{% else %}
2.  **无外部依赖:** 此函数没有外部依赖，无需Mock。
3.  **专注单元测试:** 重点测试函数的内部逻辑和边界条件。直接编写单元测试即可。
{% endif %}